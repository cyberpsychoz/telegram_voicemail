# Импортируем библиотеку telethon и другие необходимые модули
from telethon import TelegramClient, events, sync
import time
import random

# Создаем клиент телеграма с нашими учетными данными
api_id = 123456 # Ваш api_id
api_hash = 'abcdef1234567890abcdef1234567890' # Ваш api_hash
phone = '+71234567890' # Ваш номер телефона
client = TelegramClient('session_name', api_id, api_hash)

# Подключаемся к телеграму
client.start(phone)

# Получаем список контактов, с которыми будем общаться
contacts = client.get_contacts()

# Определяем параметры общения с клиентами, такие как тайминг, шаблоны сообщений, условия перехода к следующему шагу и т.д.
# Это можно сделать через интерфейс программы или через файлы конфигурации
# Здесь приведены примеры некоторых параметров для наглядности

# Тайминг - интервалы времени в секундах, через которые будем отправлять сообщения или звонить клиентам
timing = {
    'text': (10, 20), # Отправляем текстовые сообщения через 10-20 секунд после предыдущего сообщения или звонка
    'voice': (30, 60), # Отправляем голосовые сообщения через 30-60 секунд после предыдущего сообщения или звонка
    'media': (40, 80), # Отправляем медиа сообщения (фото, видео и т.д.) через 40-80 секунд после предыдущего сообщения или звонка
    'call': (120, 180), # Звоним клиентам через 120-180 секунд после предыдущего сообщения или звонка
}

# Шаблоны сообщений - списки текстовых, голосовых или медиа сообщений, которые будем отправлять клиентам в определенном порядке или случайно
templates = {
    'text': [
        'Здравствуйте, это {name} из компании {company}. Я хотел бы поговорить с вами о нашем новом продукте.',
        'Наш продукт - это уникальное решение для вашей сферы деятельности. Он поможет вам повысить эффективность, снизить затраты и увеличить прибыль.',
        'Вы можете посмотреть подробную информацию о нашем продукте на нашем сайте {website} или в нашем каталоге {catalog}.',
        'Если у вас есть вопросы или вы хотите заказать наш продукт, пожалуйста, свяжитесь со мной по телефону {phone} или по электронной почте {email}.',
        'Спасибо за ваше внимание и до свидания.'
    ],
    'voice': [
        'voice1.ogg', # Файл с голосовым сообщением №1
        'voice2.ogg', # Файл с голосовым сообщением №2
        'voice3.ogg', # Файл с голосовым сообщением №3
    ],
    'media': [
        'photo1.jpg', # Файл с фотографией №1
        'photo2.jpg', # Файл с фотографией №2
        'video1.mp4', # Файл с видео №1
        'video2.mp4', # Файл с видео №2
    ]
}

# Условия перехода к следующему шагу - функции, которые проверяют, готов ли клиент к следующему шагу общения, например, по количеству символов или секунд в его ответе
def next_step_text(message):
    # Переходим к следующему шагу, если клиент написал больше 300 символов
    return len(message.text) > 300

def next_step_voice(message):
    # Переходим к следующему шагу, если клиент отправил голосовое сообщение длительностью больше 10 секунд
    return message.voice and message.voice.attributes[0].duration > 10

def next_step_media(message):
    # Переходим к следующему шагу, если клиент отправил медиа сообщение (фото, видео и т.д.)
    return message.media

# Режимы звонков и приглашений - параметры, которые определяют, когда и как будем звонить клиентам или приглашать их на канал или группу
call_mode = {
    'enabled': True, # Включен ли режим звонков
    'always': False, # Звонить ли даже если были раньше звонки
    'message': 'Привет, это {name} из компании {company}. Я хотел бы поговорить с вами о нашем новом продукте. Пожалуйста, перезвоните мне по номеру {phone}.' # Сообщение, которое отправляем, если клиент не поднял трубку
}

invite_mode = {
    'enabled': True, # Включен ли режим приглашений
    'channel': '@my_channel', # Ссылка на канал или группу, на которую приглашаем
    'message': 'Приглашаю вас на наш канал {channel}, где вы можете узнать больше о нашем продукте и получить специальные предложения.' # Сообщение, которое отправляем с приглашением
}

# Случайная последовательность высылки сообщений - параметр, который определяет, будем ли мы отправлять сообщения из шаблонов в случайном порядке или в определенном
random_mode = False

# Создаем словарь для хранения состояния общения с каждым клиентом
# Ключ - идентификатор клиента, значение - словарь с полями:
# step - текущий шаг общения (0 - начало, 1 - текстовое сообщение, 2 - голосовое сообщение, 3 - медиа сообщение, 4 - звонок, 5 - приглашение, 6 - конец)
# index - индекс текущего сообщения в списке шаблонов для данного типа сообщения
# timer - время в секундах, через которое нужно отправить следующее сообщение или сделать звонок
# backup - список сообщений от клиента для бекапа переписки
state = {}

# Функция для инициализации состояния общения с новым клиентом
def init_state(user_id):
    state[user_id] = {
        'step': 0,
        'index': 0,
        'timer': 0,
        'backup': []
    }

# Функция для обновления состояния общения с клиентом после отправки или получения сообщения или звонка
def update_state(user_id, message=None):
    # Если это новый клиент, инициализируем его состояние
    if user_id not in state:
        init_state(user_id)
    
    # Получаем текущее состояние общения с клиентом
    current_state = state[user_id]

    # Если мы отправили сообщение или сделали звонок, то переходим к следующему шагу или индексу
    if message is None:
        # Если мы в случайном режиме, то выбираем случайный индекс из списка шаблонов для данного типа сообщения
        if random_mode:
            current_state['index'] = random.randint(0, len(templates[current_state['step']]) - 1)
        # Иначе увеличиваем индекс на единицу, если он не превышает длину списка шаблонов для данного типа сообщения
        else:
            current_state['index'] += 1
            if current_state['index'] >= len(templates[current_state['step']]):
                current_state['index'] = 0
        
        # Переходим к следующему шагу, если мы достигли конца списка шаблонов для данного типа сообщения
        if current_state['index'] == 0:
            current_state['step'] += 1
        
        # Если мы достигли конца общения, то завершаем его
        if current_state['step'] > 6:
            return
        
        # Устанавливаем таймер для следующего сообщения или звонка в зависимости от типа сообщения
        current_state['timer'] = random.randint(*timing[current_state['step']])
    
    # Если мы получили сообщение от клиента, то проверяем, готов ли он к следующему шагу или индексу
    else:
        # Добавляем сообщение от клиента в список для бекапа переписки
        current_state['backup'].append(message)

        # Проверяем, готов ли клиент к следующему шагу по условию для данного типа сообщения
        if next_step[current_state['step']](message):
            # Если да, то переходим к следующему шагу или индексу, как при отправке сообщения или звонка
            update_state(user_id)
        
        # Иначе оставляем текущее состояние без изменений и обнуляем таймер
        else:
            current_state['timer'] = 0
    
    # Сохраняем обновленное состояние общения с клиентом
    state[user_id] = current_state

# Функция для отправки сообщения или звонка клиенту в зависимости от текущего состояния общения
def send_message_or_call(user_id):
    # Получаем текущее состояние общения с клиентом
    current_state = state[user_id]

    # Определяем тип сообщения или звонка по текущему шагу общения
    message_type = current_state['step']

    # Определяем индекс сообщения в списке шаблонов для данного типа сообщения
    message_index = current_state['index']

    # Определяем контент сообщения по индексу в списке шаблонов для данного типа сообщения
    message_content = templates[message_type][message_index]

    # Если это текстовое сообщение, то подставляем в него переменные из нашего профиля, такие как имя, компания, сайт и т.д.
    if message_type == 'text':
        message_content = message_content.format(
            name = 'Иван', # Ваше имя
            company = 'ООО "Рога и копыта"', # Название вашей компании
            website = 'https://rogaikopyta.ru', # Ссылка на ваш сайт
            catalog = 'https://rogaikopyta.ru/catalog.pdf', # Ссылка на ваш каталог
            phone = '+71234567890', # Ваш номер телефона
            email = 'ivan@rogaikopyta.ru' # Ваш адрес электронной почты
        )
    
    # Отправляем сообщение или звонок клиенту в зависимости от типа сообщения
    if message_type == 'text':
        # Отправляем текстовое сообщение
        client.send_message(user_id, message_content)
    elif message_type == 'voice':
        # Отправляем голосовое сообщение
        client.send_file(user_id, message_content, voice_note=True)
    elif message_type == 'media':
        # Отправляем медиа сообщение (фото, видео и т.д.)
        client.send_file(user_id, message_content)
    elif message_type == 'call':
        # Звоним клиенту
        call = client.call(user_id)
        # Если клиент не поднял трубку, то отправляем ему сообщение с нашим номером и просьбой перезвонить
        if not call.answered:
            call.hangup()
            message_content = call_mode['message'].format(
                name = 'Иван', # Ваше имя
                company = 'ООО "Рога и копыта"', # Название вашей компании
                phone = '+71234567890' # Ваш номер телефона
            )
            client.send_message(user_id, message_content)
    elif message_type == 'invite':
        # Приглашаем клиента на наш канал или группу
        client(InviteToChannelRequest(current_state['channel'], [user_id]))
        # Отправляем ему сообщение с приглашением
        message_content = invite_mode['message'].format(
            channel = invite_mode['channel'] # Ссылка на наш канал или группу
        )
        client.send_message(user_id, message_content)
    
    # Обновляем состояние общения с клиентом после отправки сообщения или звонка
    update_state(user_id)

# Функция для получения сообщения или звонка от клиента и обработки его
@client.on(events.NewMessage(incoming=True))
def receive_message_or_call(event):
    # Получаем идентификатор клиента, который отправил нам сообщение или звонок
    user_id = event.sender_id

    # Получаем сообщение или звонок от клиента
    message = event.message

    # Обновляем состояние общения с клиентом после получения сообщения или звонка
    update_state(user_id, message)

# Функция для удаления сообщений по сроку годности
def delete_messages():
    # Проходим по всем контактам, с которыми общаемся
    for user_id in contacts:
        # Получаем список всех наших сообщений с данным контактом
        messages = client.get_messages(user_id, from_user='me')
        # Проходим по всем нашим сообщениям с данным контактом
        for message in messages:
            # Если сообщение имеет срок годности, то проверяем, не истек ли он
            if message.ttl > 0:
                # Если срок годности истек, то удаляем сообщение
                if time.time() - message.date > message.ttl:
                    message.delete()

# Функция для экспорта бекапа переписки с клиентом в файл
def export_backup(user_id):
    # Получаем список сообщений от клиента для бекапа переписки
    messages = state[user_id]['backup']

    # Создаем имя файла для бекапа переписки в формате дата_ник_аккаунта.txt
    file_name = time.strftime('%Y-%m-%d') + '_' + client.get_entity(user_id).username + '.txt'

    # Открываем файл для записи в режиме добавления
    with open(file_name, 'a') as file:
        # Проходим по всем сообщениям от клиента для бекапа переписки
        for message in messages:
            # Записываем в файл дату и время сообщения, тип сообщения и его контент (текст, файл или ссылка)
            file.write(message.date.strftime('%Y-%m-%d %H:%M:%S') + '\t')
            if message.text:
                file.write('text\t' + message.text + '\n')
            elif message.file:
                file.write('file\t' + message.file.name + '\n')
            elif message.web_preview:
                file.write('link\t' + message.web_preview.url + '\n')
            else:
                file.write('unknown\t\n')
        
        # Очищаем список сообщений от клиента для бекапа переписки
        state[user_id]['backup'] = []

# Запускаем основной цикл программы
while True:
    # Проходим по всем контактам, с которыми общаемся
    for user_id in contacts:
        # Получаем текущее состояние общения с клиентом
        current_state = state[user_id]

        # Если таймер не равен нулю, то уменьшаем его на единицу
        if current_state['timer'] > 0:
            current_state['timer'] -= 1
        
        # Если таймер равен нулю, то отправляем сообщение или звонок клиенту
        if current_state['timer'] == 0:
            send_message_or_call(user_id)
    
    # Удаляем сообщения по сроку годности
    delete_messages()

    # Экспортируем бекап переписки с клиентами в файлы
    for user_id in contacts:
        export_backup(user_id)
    
    # Ждем одну секунду перед следующей итерацией цикла
    time.sleep(1)